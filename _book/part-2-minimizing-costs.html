<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Parte 2 Part 2 - Minimizing Costs | Inteligencia Artificial aplicada a Negocios y Empresas</title>
  <meta name="description" content="Asienta las bases para convertirte en el Data Scientist del futuro con todo el contenido de estadística descriptiva del curso. En particular verás los mismos contenidos que explicamos en primero de carrera a matemáticos, ingenieros, economistas, biólogos, médicos o informáticos." />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Parte 2 Part 2 - Minimizing Costs | Inteligencia Artificial aplicada a Negocios y Empresas" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://www.udemy.com/course/ia4business/?couponCode=B85F8D52148DF5AAD8F7" />
  <meta property="og:image" content="https://www.udemy.com/course/ia4business/?couponCode=B85F8D52148DF5AAD8F7Images/cover.jpg" />
  <meta property="og:description" content="Asienta las bases para convertirte en el Data Scientist del futuro con todo el contenido de estadística descriptiva del curso. En particular verás los mismos contenidos que explicamos en primero de carrera a matemáticos, ingenieros, economistas, biólogos, médicos o informáticos." />
  <meta name="github-repo" content="https://github.com/joanby/ia4business" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Parte 2 Part 2 - Minimizing Costs | Inteligencia Artificial aplicada a Negocios y Empresas" />
  
  <meta name="twitter:description" content="Asienta las bases para convertirte en el Data Scientist del futuro con todo el contenido de estadística descriptiva del curso. En particular verás los mismos contenidos que explicamos en primero de carrera a matemáticos, ingenieros, economistas, biólogos, médicos o informáticos." />
  <meta name="twitter:image" content="https://www.udemy.com/course/ia4business/?couponCode=B85F8D52148DF5AAD8F7Images/cover.jpg" />

<meta name="author" content="Hadelin de Ponteves y Kirill Ermenko" />


<meta name="date" content="2020-03-19" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="Images/apple-icon-120x120.png" />
  <link rel="shortcut icon" href="Images/favicon.ico" type="image/x-icon" />
<link rel="prev" href="optimización-de-procesos.html"/>
<link rel="next" href="part-3-maximizing-revenues.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Inteligencia Artificial aplicada Negocios y Empresas</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introducción</a></li>
<li class="chapter" data-level="1" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html"><i class="fa fa-check"></i><b>1</b> Optimización de Procesos</a><ul>
<li class="chapter" data-level="1.1" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#caso-práctico-optimización-de-tareas-en-un-almacén-de-comercio-electrónico"><i class="fa fa-check"></i><b>1.1</b> Caso Práctico: Optimización de tareas en un almacén de comercio electrónico</a><ul>
<li class="chapter" data-level="1.1.1" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#problema-a-resolver"><i class="fa fa-check"></i><b>1.1.1</b> Problema a resolver</a></li>
<li class="chapter" data-level="1.1.2" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#entorno-a-definir"><i class="fa fa-check"></i><b>1.1.2</b> Entorno a definir</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#solución-de-inteligencia-artificial"><i class="fa fa-check"></i><b>1.2</b> Solución de Inteligencia Artificial</a><ul>
<li class="chapter" data-level="1.2.1" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#proceso-de-decisión-de-markov"><i class="fa fa-check"></i><b>1.2.1</b> Proceso de Decisión de Markov</a></li>
<li class="chapter" data-level="1.2.2" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#q-learning"><i class="fa fa-check"></i><b>1.2.2</b> Q-Learning</a></li>
<li class="chapter" data-level="1.2.3" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#el-algoritmo-de-q-learning-al-completo"><i class="fa fa-check"></i><b>1.2.3</b> El algoritmo de Q-Learning al completo</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="optimización-de-procesos.html"><a href="optimización-de-procesos.html#implementación"><i class="fa fa-check"></i><b>1.3</b> Implementación</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="part-2-minimizing-costs.html"><a href="part-2-minimizing-costs.html"><i class="fa fa-check"></i><b>2</b> Part 2 - Minimizing Costs</a><ul>
<li class="chapter" data-level="2.1" data-path="part-2-minimizing-costs.html"><a href="part-2-minimizing-costs.html#case-study-minimizing-costs-in-energy-consumption-of-a-data-center"><i class="fa fa-check"></i><b>2.1</b> Case Study: Minimizing Costs in Energy Consumption of a Data Center</a><ul>
<li class="chapter" data-level="2.1.1" data-path="part-2-minimizing-costs.html"><a href="part-2-minimizing-costs.html#problem-to-solve"><i class="fa fa-check"></i><b>2.1.1</b> Problem to solve</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="part-3-maximizing-revenues.html"><a href="part-3-maximizing-revenues.html"><i class="fa fa-check"></i><b>3</b> Part 3 - Maximizing Revenues</a><ul>
<li class="chapter" data-level="3.1" data-path="part-3-maximizing-revenues.html"><a href="part-3-maximizing-revenues.html#case-study-maximizing-revenue-of-an-online-retail-business"><i class="fa fa-check"></i><b>3.1</b> Case Study: Maximizing Revenue of an Online Retail Business</a><ul>
<li class="chapter" data-level="3.1.1" data-path="part-3-maximizing-revenues.html"><a href="part-3-maximizing-revenues.html#problem-to-solve-1"><i class="fa fa-check"></i><b>3.1.1</b> Problem to solve</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="conclusion.html"><a href="conclusion.html"><i class="fa fa-check"></i>Conclusion</a></li>
<li class="chapter" data-level="4" data-path="annex-1-artificial-neural-networks.html"><a href="annex-1-artificial-neural-networks.html"><i class="fa fa-check"></i><b>4</b> Annex 1: Artificial Neural Networks</a></li>
<li class="chapter" data-level="5" data-path="annex-2-three-extra-ai-models.html"><a href="annex-2-three-extra-ai-models.html"><i class="fa fa-check"></i><b>5</b> Annex 2: Three Extra AI Models</a></li>
<li class="chapter" data-level="6" data-path="annex-3-questions-and-answers.html"><a href="annex-3-questions-and-answers.html"><i class="fa fa-check"></i><b>6</b> Annex 3: Questions and Answers</a></li>
<li class="divider"></li>
<li><a href="https://www.udemy.com/course/ia4business/?couponCode=B85F8D52148DF5AAD8F7" target="blank">Curso en Udemy</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Inteligencia Artificial aplicada a Negocios y Empresas</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="part-2---minimizing-costs" class="section level1">
<h1><span class="header-section-number">Parte 2</span> Part 2 - Minimizing Costs</h1>
<p>Congratulations for smashing the first case study! Let’s move on to a brand new and more advanced AI.</p>
<div id="case-study-minimizing-costs-in-energy-consumption-of-a-data-center" class="section level2">
<h2><span class="header-section-number">2.1</span> Case Study: Minimizing Costs in Energy Consumption of a Data Center</h2>
<div id="problem-to-solve" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Problem to solve</h3>
<p>In 2016,  using their DQN AI model (Deep Q-Learning). In this case study, we will do something very similar. We will set up our own server environment, and we will build an AI that will be controlling the cooling/heating of the server so that it stays in an optimal range of temperatures while saving the maximum energy, therefore minimizing the costs. And just as DeepMind AI did, our goal will be to achieve at least 40% energy saving.</p>

<p>Before we define the states, actions and rewards, we need to explain how the server operates. We will do that in several steps. First, we will list all the environment parameters and variables by which the server is controlled. After that we will set the essential assumption of the problem, on which our AI will rely to provide a solution. Then we will specify how we will simulate the whole process. And eventually we will explain the overall functioning of the server, and how the AI plays its role.</p>
<p><br />
</p>
<p></p>

<p></p>

<p>All these parameters and variables will be part of our server environment and will influence the actions of the AI on the server.</p>
<p><br />
</p>
<p>Then let’s give and explain below the two core assumptions of the environment. It is important to understand that these assumptions are not AI related, but just used to simplify the environment so that we can focus the maximum on the AI solution.</p>
<p><br />
</p>
<p></p>
<p><br />
</p>
<p>We will rely on the following two essential assumptions:</p>
<p><br />
</p>
<p>:</p>
<p><span class="math display">\[\begin{equation*}
    \textrm{server temperature} = b_0 + b_1 \times \textrm{atmospheric temperature} + b_2 \times \textrm{number of users} + b_3 \times \textrm{data transmission rate} 
\end{equation*}\]</span></p>
<p>where <span class="math inline">\(b_0 \in \mathbb{R}\)</span>, <span class="math inline">\(b_1&gt;0\)</span>, <span class="math inline">\(b_2&gt;0\)</span> and <span class="math inline">\(b_3&gt;0\)</span>.</p>
<p><br />
</p>
<p>The raison d’être of this assumption and the reason why <span class="math inline">\(b_1&gt;0\)</span>, <span class="math inline">\(b_2&gt;0\)</span> and <span class="math inline">\(b_3&gt;0\)</span> are intuitive to understand. Indeed, it makes sense that when the atmospheric temperature increases, the temperature of the server increases. Also, the more users are active in the server, the more the server has to spend energy to handle them and therefore the higher the temperature of the server will be. And finally of course, the more data is transmitted inside the server, the more the server has to spend energy to process it, and therefore the higher temperature of the server will be. And for simplicity purposes, we just suppose that these correlations are linear. However you could totally run the same simulation by assuming they are quadratic or logarithmic. Feel free to tweak around.</p>
<p><br />
</p>
<p>Eventually, let’s assume further that after performing this Multiple Linear Regression, we obtained the following values of the coefficients: <span class="math inline">\(b_0 = 0\)</span>, <span class="math inline">\(b_1 = 1\)</span>, <span class="math inline">\(b_2 = 1.25\)</span> and <span class="math inline">\(b_3 = 1.25\)</span>. Accordingly:</p>
<p><span class="math display">\[\begin{equation*}
    \textrm{server temperature} = \textrm{atmospheric temperature} + 1.25 \times \textrm{number of users} + 1.25 \times \textrm{data transmission rate}
\end{equation*}\]</span></p>
<p><br />
</p>
<p></p>
<p><span class="math display">\[\begin{equation*}
    E_t = \alpha |\Delta T_t| + \beta = \alpha |T_{t+1} - T_t| + \beta
\end{equation*}\]</span></p>
<p>where:</p>
<p><span class="math display">\[\begin{equation*}
\begin{cases}
\textrm{$E_t$ is the energy spent by the system onto the server between times $t$ and $t$ + 1 minute} \\
\textrm{$\Delta T_t$ is the change of the server&#39;s temperature caused by the system between times $t$ and $t$ + 1 minute} \\
\textrm{$T_t$ is the temperature of the server at time $t$} \\
\textrm{$T_{t+1}$ is the temperature of the server at time $t$ + 1 minute} \\
\alpha &gt; 0 \\
\beta \in \mathbb{R}
\end{cases}
\end{equation*}\]</span></p>
<p>Again, let’s explain why it intuitively makes sense to make this assumption with <span class="math inline">\(\alpha &gt; 0\)</span>. That’s simply because the more the AI heats up or cools down the server, the more it spends energy to do that heat transfer. Indeed for example, imagine the server suddenly has overheating issues and just reached <span class="math inline">\(80 \degree\)</span>C, then within one unit of time (1 minute) the AI will need much more energy to bring the server’s temperature back to its optimal temperature <span class="math inline">\(24 \degree\)</span>C than to bring it back to <span class="math inline">\(50 \degree\)</span>C for example. And again for simplicity purposes, we just suppose that these correlations are linear. Also (in case you are wondering), why do we take the absolute value? That’s simply because when the AI cools down the server, <span class="math inline">\(T_{t+1} &lt; T_t\)</span>, so <span class="math inline">\(\Delta T &lt; 0\)</span>. And of course an energy is always positive so we have to take the absolute value of <span class="math inline">\(\Delta T\)</span>.</p>
<p><br />
</p>
<p>Eventually, for further simplicity purposes we will also assume that the results of the regression are <span class="math inline">\(\alpha = 1\)</span> and <span class="math inline">\(\beta = 0\)</span>, so that we get, the following final equation based on Assumption 2:</p>
<p><span class="math display">\[\begin{equation*}
E_t = |\Delta T_t| = |T_{t+1} - T_t| =
\begin{cases}
T_{t+1} - T_t &amp; \textrm{if $T_{t+1} &gt; T_t$, that is if the server is heated up} \\
T_t - T_{t+1} &amp; \textrm{if $T_{t+1} &lt; T_t$, that is if the server is cooled down}
\end{cases}
\end{equation*}\]</span></p>
<p><br />
</p>
<p>Now let’s explain how we will simulate the server operating with the users and data coming in and out.</p>
<p><br />
</p>
<p></p>
<p><br />
</p>
<p>The number of users and the rate of data transmission will be randomly fluctuating to simulate an actual server. This leads to randomness in the temperature and the AI has to understand how much cooling or heating power it has to transfer to the server so as to not deteriorate the server performance and at the same time, expend the least energy by optimizing its heat transfer.</p>
<p><br />
</p>
<p>Now that we have the full picture, let’s explain the overall functioning of the server and the AI inside this environment.</p>
<p><br />
</p>
<p></p>
<p><br />
</p>
<p>Inside a data center, we are dealing with a specific server that is controlled by the parameters and variables listed above. Every minute, some new users log on to the server and some current users log off, therefore updating the number of active users in the server. Same, every minute some new data is transmitted into the server, and some existing data is transmitted outside the server, therefore updating the rate of data transmission happening inside the server. Hence, based on Assumption 1 given above, the temperature of the server is updated every minute. Now please focus, because this is where you will understand the huge role the AI has to play on the server. Two possible systems can regulate the temperature of the server: the AI, or the server’s integrated cooling system. The server’s integrated cooling system is an unintelligent system that will automatically bring back the server’s temperature to its optimal temperature. Let’s explain this in more details: when the server’s temperature is updated every minute, it can either stay within the range of optimal temperatures (<span class="math inline">\([18 \degree \textrm{C}, 24 \degree \textrm{C}]\)</span>), or go outside this range. If it goes outside the optimal range, like say <span class="math inline">\(30 \degree\)</span>C, the server’s integrated cooling system will automatically bring the temperature back to the closest bound of the optimal range, that is <span class="math inline">\(24 \degree\)</span>C. However this server’s integrated cooling system will do that only when the AI is not activated. If the AI is activated, then in that case the server’s integrated cooling system is deactivated and it is the AI itself that updates the temperature of the server to regulate it the best way. But the AI does that after some prior predictions, not in a deterministic way as with the unintelligent server’s integrated cooling system. Before there is an update of the number of users and the rate of data transmission causing to change the temperature of the server, the AI predicts if it should cool down the server, do nothing, or heat up the server. Then the temperature change happens and the AI reiterates. And since these two systems are complementary, we will evaluate them separately to compare their performance.</p>
<p>And that brings us to the energy. Indeed remember that one primary goal of the AI is to save some energy spent on this server. Accordingly, our AI has to spend less energy than the energy spent by the unintelligent cooling system onto the server. And since, based on Assumption 2 given above, the energy spent on the server (by any system) is proportional to the change of temperature within one unit of time:</p>
<p><span class="math display">\[\begin{equation*}
E_t = |\Delta T_t| = \alpha |T_{t+1} - T_t| =
\begin{cases}
T_{t+1} - T_t &amp; \textrm{if $T_{t+1} &gt; T_t$, that is if the server is heated up} \\
T_t - T_{t+1} &amp; \textrm{if $T_{t+1} &lt; T_t$, that is if the server is cooled down}
\end{cases}
\end{equation*}\]</span></p>
<p><br />
</p>
<p>then that means that the energy saved by the AI at each iteration <span class="math inline">\(t\)</span> (each minute) is in fact the difference in absolute changes of temperatures caused on the server between the unintelligent server’s integrated cooling system and the AI from <span class="math inline">\(t\)</span> and <span class="math inline">\(t+1\)</span>:</p>
<p><span class="math display">\[\begin{align*}
        \textrm{Energy saved by the AI between $t$ and $t+1$}
        &amp; = |\Delta T_t^{\textrm{Server&#39;s Integrated Cooling System}}| - |\Delta T_t^{\textrm{AI}}| \\
        &amp; = |\Delta T_t^{\textrm{noAI}}| - |\Delta T_t^{\textrm{AI}}|
\end{align*}\]</span></p>
<p>where:</p>
<p><span class="math display">\[\begin{equation*}
\begin{cases}
\textrm{$\Delta T_t^{\textrm{noAI}}$ is the change of temperature that the server&#39;s integrated cooling system would cause} \\
\textrm{without the AI onto the server during the iteration $t$, that is from $t$ to $t+1$ minute} \\
\textrm{$\Delta T_t^{\textrm{AI}}$ is the change of temperature caused by the AI onto the server during the iteration $t$,} \\
\textrm{that is from $t$ to $t+1$ minute}
\end{cases}
\end{equation*}\]</span></p>
<p><br />
</p>
<p>Our goal will be to save the maximum energy each minute, therefore saving the maximum total energy over 1 full year of simulation, and eventually saving the maximum costs in the cooling/heating electricity bill.</p>
<p><br />
</p>
<p>Are you ready?</p>
<p><br />
</p>
<p>Great! Now that we fully understand how our server environment works and how it is simulated, it is time to proceed with what must be absolutely done when defining an AI environment:</p>
<p><br />
</p>

<p><br />
</p>
<p></p>
<p><br />
</p>
<p>The input state <span class="math inline">\(s_t\)</span> at time <span class="math inline">\(t\)</span> is composed of the following three elements:</p>

<p>Thus the input state will be an input vector of these three elements. Our future AI will take this vector as input, and will return the action to play at each time <span class="math inline">\(t\)</span>.</p>
<p><br />
</p>
<p></p>
<p><br />
</p>
<p>The actions are simply the temperature changes that the AI can cause inside the server, in order to heat it up or cool it down. In order to make our actions discrete, we will consider 5 possible temperature changes from <span class="math inline">\(-3 \degree\)</span>C to <span class="math inline">\(+3 \degree\)</span>C, so that we end up with the 5 following possible actions that the AI can play to regulate the temperature of the server:</p>

<p></p>
<p><br />
</p>
<p>After reading the “Overall functioning” paragraph above you might guess what the reward is going to be. Of course, the reward at iteration <span class="math inline">\(t\)</span> is the energy spent on the server that the AI is saving with respect to the server’s integrated cooling system, that is, the difference between the energy that the unintelligent cooling system would spend if the AI was deactivated and the energy that the AI spends onto the server:</p>
<p><span class="math display">\[\begin{equation*}
    \textrm{Reward}_t = E_t^{\textrm{noAI}} - E_t^{\textrm{AI}}
\end{equation*}\]</span></p>
<p>And since (Assumption 2), the energy spent is equal to the change of the temperature caused on the server (by any system, including the AI or the unintelligent cooling system):</p>
<p><span class="math display">\[\begin{equation*}
E_t = |\Delta T_t| = \alpha |T_{t+1} - T_t| =
\begin{cases}
T_{t+1} - T_t &amp; \textrm{if $T_{t+1} &gt; T_t$, that is if the server is heated up} \\
T_t - T_{t+1} &amp; \textrm{if $T_{t+1} &lt; T_t$, that is if the server is cooled down}
\end{cases}
\end{equation*}\]</span></p>
<p>then we get that the reward received at time <span class="math inline">\(t\)</span> is in fact the difference in change of temperatures caused on the server between unintelligent cooling system (that is when there is no AI) and the AI:</p>
<p><span class="math display">\[\begin{align*}
    \textrm{Reward}_t
    &amp; = \textrm{Energy saved by the AI between $t$ and $t+1$} \\
    &amp; = E_t^{\textrm{noAI}} - E_t^{\textrm{AI}} \\
    &amp; = |\Delta T_t^{\textrm{noAI}}| - |\Delta T_t^{\textrm{AI}}|
\end{align*}\]</span></p>
<p>where:</p>
<p><span class="math display">\[\begin{equation*}
\begin{cases}
\textrm{$\Delta T_t^{\textrm{noAI}}$ is the change of temperature that the server&#39;s integrated cooling system would cause} \\
\textrm{without the AI onto the server during the iteration $t$, that is from $t$ to $t+1$ minute} \\
\textrm{$\Delta T_t^{\textrm{AI}}$ is the change of temperature caused by the AI onto the server during the iteration $t$,} \\
\textrm{that is from $t$ to $t+1$ minute}
\end{cases}
\end{equation*}\]</span></p>
<p><br />
</p>
<p> it is important to understand that the systems (our AI and the server’s cooling system) will be evaluated separately, in order to compute the rewards. And since each time their actions lead to different temperatures, we will have to keep track separately of the two temperatures <span class="math inline">\(T_t^{\textrm{AI}}\)</span> and <span class="math inline">\(T_t^{\textrm{noAI}}\)</span>.</p>
<p><br />
</p>
<p>Now to finish this section we are going to do a small simulation of 2 iterations (i.e. 2 minutes), as an example that will make everything crystal clear.</p>
<p></p>
<p><br />
</p>
<p>Let’s say that we are at time <span class="math inline">\(t = 4:00\)</span> pm and that the temperature of the server is <span class="math inline">\(T_t = 28 \degree\)</span>C, both with the AI and without the AI. At this exact time, the AI predicts the action 0, 1, 2, 3 or 4. Since right now the server’s temperature is outside the optimal temperature range <span class="math inline">\([18 \degree \textrm{C}, 24 \degree \textrm{C}]\)</span>, the AI will probably predict actions 0, 1 or 2. Let’s say that it predicts 1, which corresponds to cooling the server down by <span class="math inline">\(1.5 \degree\)</span>C. Therefore, between <span class="math inline">\(t = 4:00\)</span> pm and <span class="math inline">\(t+1 = 4:01\)</span> pm, the AI makes the server’s temperature go from <span class="math inline">\(T_t^{\textrm{AI}} = 28 \degree \textrm{C}\)</span> to <span class="math inline">\(T_{t+1}^{\textrm{AI}} = 26.5 \degree \textrm{C}\)</span>:</p>
<p><span class="math display">\[\begin{align*}
    \Delta T_t^{\textrm{AI}}
    &amp; = T_{t+1}^{\textrm{AI}} - T_t^{\textrm{AI}} \\
    &amp; = 26.5 - 27 \\
    &amp; = -1.5 \degree \textrm{C}
\end{align*}\]</span></p>
<p>Thus, based on Assumption 2, the energy spent by the AI onto the server is:</p>
<p><span class="math display">\[\begin{align*}
    E_t^{\textrm{AI}}
    &amp; = |\Delta T_t^{\textrm{AI}}| \\
    &amp; = 1.5 \ \textrm{Joules}
\end{align*}\]</span></p>
<p>Good, now only one info is missing to compute the reward: it is the energy that the server’s integrated cooling system would have spent if the AI was deactivated between 4:00pm and 4:01pm. Remember that this unintelligent cooling system is automatically bringing the server’s temperature back to the closest bound of the optimal temperature range <span class="math inline">\([18 \degree \textrm{C}, 24 \degree \textrm{C}]\)</span>. So since at <span class="math inline">\(t = 4:00\)</span> pm the temperature was <span class="math inline">\(T_t = 28 \degree\)</span>C, then the closest bound of the optimal temperature range at that time was <span class="math inline">\(24 \degree\)</span>C. Thus the server’s integrated cooling system would have changed the temperature from <span class="math inline">\(T_t = 28 \degree \textrm{C}\)</span> to <span class="math inline">\(T_{t+1} = 24 \degree \textrm{C}\)</span>, and therefore the server’s temperature change that would have occurred if there was no AI is:</p>
<p><span class="math display">\[\begin{align*}
    \Delta T_t^{\textrm{noAI}}
    &amp; = T_{t+1}^{\textrm{noAI}} - T_t^{\textrm{noAI}} \\
    &amp; = 24 - 28 \\
    &amp; = -4 \degree C
\end{align*}\]</span></p>
<p><br />
</p>
<p>Thus, based on Assumption 2, the energy that the unintelligent cooling system would have spent if there was no AI is:</p>
<p><span class="math display">\[\begin{align*}
    E_t^{\textrm{noAI}}
    &amp; = |\Delta T_t^{\textrm{noAI}}| \\
    &amp; = 4 \ \textrm{Joules}
\end{align*}\]</span></p>
<p><br />
</p>
<p>Hence in conclusion, the reward we get after playing this action at time <span class="math inline">\(t = 4:00\)</span> pm is:</p>
<p><span class="math display">\[\begin{align*}
    \textrm{Reward}
    &amp; = E_t^{\textrm{noAI}} - E_t^{\textrm{AI}} \\
    &amp; = 4 - 1.5 \\
    &amp; = 2.5
\end{align*}\]</span></p>
<p><br />
</p>
<p>Then, between <span class="math inline">\(t = 4:00\)</span> pm and <span class="math inline">\(t+1 = 4:01\)</span> pm, other things happen: some new users are logging on to the server, some existing users are logging off the server, some new data is transmitting inside the server, and some existing data is transmitting outside the server. Based on Assumption 1, these factors make the server’s temperature change. Let’s say they increase the server’s temperature by <span class="math inline">\(5 \degree\)</span>C:</p>
<p><span class="math display">\[\begin{equation*}
    \Delta_t \ \textrm{Intrinsic Temperature} = 5 \degree C
\end{equation*}\]</span></p>
<p><br />
</p>
<p>Now remember that we are evaluating two systems separately: our AI, and the server’s integrated cooling system. Therefore we must compute separately the two temperatures we would get with these two systems at <span class="math inline">\(t+1 = 4:01\)</span> pm. Let’s start with the AI.</p>
<p><br />
</p>
<p>The temperature we get at <span class="math inline">\(t+1 = 4:01\)</span> pm when the AI is activated is:</p>
<p><span class="math display">\[\begin{align*}
    T_{t+1}^{\textrm{AI}}
    &amp; = T_t^{\textrm{AI}} + \Delta T_t^{\textrm{AI}} + \Delta_t \ \textrm{Intrinsic Temperature} \\
    &amp; = 28 + (-1.5) + 5 \\
    &amp; = 31.5 \degree C
\end{align*}\]</span></p>
<p>And the temperature we get at <span class="math inline">\(t+1 = 4:01\)</span> pm when the AI is not activated is:</p>
<p><span class="math display">\[\begin{align*}
    T_{t+1}^{\textrm{noAI}}
    &amp; = T_t^{\textrm{noAI}} + \Delta T_t^{\textrm{noAI}} + \Delta_t \ \textrm{Intrinsic Temperature} \\
    &amp; = 28 + (-4) + 5 \\
    &amp; = 29 \degree C
\end{align*}\]</span></p>
<p>Perfect, we have our two separate temperatures, which are <span class="math inline">\(T_{t+1}^{\textrm{AI}} = 29.5 \degree C\)</span> when the AI is activated, and <span class="math inline">\(T_{t+1}^{\textrm{noAI}} = 27 \degree C\)</span> when the AI is not activated.</p>
<p><br />
</p>
<p>Now let’s simulate what happens between <span class="math inline">\(t+1 = 4:01\)</span> pm and <span class="math inline">\(t+2 = 4:02\)</span> pm. Again, our AI will make a prediction, and since the server is heating up, let’s say it predicts action 0, which corresponds to cooling down the server by <span class="math inline">\(3 \degree C\)</span>, bringing it down to <span class="math inline">\(T_{t+2}^{\textrm{AI}} = 28.5 \degree C\)</span>. Therefore, the energy spent by the AI between <span class="math inline">\(t+1 = 4:01\)</span> pm and <span class="math inline">\(t+2 = 4:02\)</span> pm, is:</p>
<p><span class="math display">\[\begin{align*}
    E_{t+1}^{\textrm{AI}}
    &amp; = |\Delta T_{t+1}^{\textrm{AI}}| \\
    &amp; = |28.5 - 31.5| \\
    &amp; = 3 \ \textrm{Joules}
\end{align*}\]</span></p>
<p>Now regarding the server’s integrated cooling system (i.e. when there is no AI), since at <span class="math inline">\(t+1 = 4:01\)</span> pm we had <span class="math inline">\(T_{t+1}^{\textrm{noAI}} = 29 \degree C\)</span>, then the closest bound of the optimal range of temperatures is still <span class="math inline">\(24 \degree C\)</span>, and so the energy that the server’s unintelligent cooling system would spend between <span class="math inline">\(t+1 = 4:01\)</span> pm and <span class="math inline">\(t+2 = 4:02\)</span> pm, is:</p>
<p><span class="math display">\[\begin{align*}
    E_{t+1}^{\textrm{noAI}}
    &amp; = |\Delta T_{t+1}^{\textrm{noAI}}| \\
    &amp; = |24 - 29| \\
    &amp; = 5 \ \textrm{Joules}
\end{align*}\]</span></p>
<p>Hence the reward obtained between <span class="math inline">\(t+1 = 4:01\)</span> pm and <span class="math inline">\(t+2 = 4:02\)</span> pm, is:</p>
<p><span class="math display">\[\begin{align*}
    \textrm{Reward}
    &amp; = E_{t+1}^{\textrm{noAI}} - E_{t+1}^{\textrm{AI}} \\
    &amp; = 5 - 3 \\
    &amp; = 2
\end{align*}\]</span></p>
<p>And finally, the total reward obtained between <span class="math inline">\(t = 4:00\)</span> pm and <span class="math inline">\(t+2 = 4:02\)</span> pm, is:</p>
<p><span class="math display">\[\begin{align*}
    \textrm{Total Reward}
    &amp; = (\textrm{Reward obtained between $t$ and $t+1$}) + (\textrm{Reward obtained between $t+1$ and $t+2$}) \\
    &amp;  = 2.5 + 2 \\
    &amp; = 4.5
\end{align*}\]</span></p>
<p>That was an example of the whole process happening in two minutes. In our implementation we will run the same process over 1000 epochs of 5-months period for the training, and then, once our AI is trained, we will run the same process over 1 full year of simulation for the testing. The training will be done with Deep Q-Learning, and this is where the next section comes into play.</p>

<p>The AI Solution that will solve the problem described above is a Deep Q-Learning model. Let’s give the intuition and the maths equations behind it.</p>

<p>Deep Q-Learning consists of combining Q-Learning to an Artificial Neural Network. Inputs are encoded vectors, each one defining a state of the environment. These inputs go into an Artificial Neural Network, where the output is the action to play. More precisely, let’s say the game has n possible actions, the output layer of the neural network is comprised of n output neurons, each one corresponding to the Q-values of each action played in the current state. Then the action played is the one associated with the output neuron that has the highest Q-value (argmax), or the one returned by the softmax method. In our case we will use argmax. And since Q-values are real numbers, that makes our neural network an ANN for Regression.</p>
<p><br />
</p>
<p>Hence, in each state <span class="math inline">\(s_t\)</span>:</p>

<p>Then this loss error is backpropagated into the network, and the weights are updated according to how much they contributed to the error.</p>

<p>We notice that so far we have only considered transitions from one state <span class="math inline">\(s_t\)</span> to the next state <span class="math inline">\(s_{t+1}\)</span>. The problem with this is that <span class="math inline">\(s_t\)</span> is most of the time very correlated with <span class="math inline">\(s_{t+1}\)</span>. Therefore the network is not learning much. This could be way improved if, instead of considering only this one previous transition, we considered the last m transitions where m is a large number. This pack of the last m transitions is what is called the Experience Replay. Then from this Experience Replay we take some random batches of transitions to make our updates.</p>

<p>The brain, or more precisely the deep neural network of our AI, will be a fully connected neural network, composed of two hidden layers, the first one having 64 neurons, and the second one having 32 neurons. And as a reminder, this neural network takes as inputs the states of the environment, and returns as outputs the Q-Values for each of the 5 actions. This artificial brain will be trained with a “Mean Squared Error” loss, and an Adam optimizer.</p>
<p><br />
</p>
<p>Here is what this artificial brain looks like:</p>

<p>This artificial brain looks complex to create, but we will build it very easily thanks to the amazing Keras library. Here is actually a preview of the full implementation containing the part that builds this brain all by itself:</p>
<p><br />
</p>

<p><br />
</p>
<p>As we can see gladly, it only took a couple lines of code.</p>

<p><br />
</p>
<p>Let’s summarize the different steps of the whole Deep Q-Learning process:</p>
<p><br />
</p>
<p>:</p>
<p><br />
</p>
<p>The memory of the Experience Replay is initialized to an empty list <span class="math inline">\(M\)</span>.</p>
<p><br />
</p>
<p>We choose a maximum size of the memory. In our case study we choose a maximum size of 100 transitions.</p>
<p><br />
</p>
<p>We start in a first state, corresponding to a specific time within the year.</p>
<p><br />
</p>
<p>:</p>

<div style="page-break-after: always;"></div>

<p><br />
</p>
<p>This implementation will be divided in 5 parts, each part having its own python file. These 5 parts constitute the general AI Framework, or AI Blueprint, that should be followed whenever we build an environment to solve any business problem with Deep Reinforcement Learning.</p>
<p><br />
</p>
<p>Here they are, from Step 1 to Step 5:</p>
<p><br />
</p>

<p><br />
</p>
<p>These are the main steps (in that same order) of the general AI Framework. Let’s thus implement our AI for our specific case study, following this AI Blueprint, in the following five sections corresponding to these five main steps. Besides in each step, we will distinguish the sub-steps that are still part of the general AI Framework, from the sub-steps that are specific to our case study, by writing the titles of the code sections in capital letters for all the sub-steps of the general AI Framework, and in minimal letters for all the sub-steps specific to our case study. That means that anytime you see a new code section of which the title is written in capital letters, then it is the next sub-step of the general AI Framework, which you should also follow when building an AI for your own business problem.</p>
<p><br />
</p>
<p>So now here we go with the beginning of the journey: Step 1 - Building the Environment.</p>
<p><br />
</p>
<p>This is the largest Python implementation file of this case study, and of the course. So please make sure to rest before, recharge your batteries to get a good energy level, and as soon as you are ready, let’s tackle this together!</p>
<p><br />
</p>
<p>We begin in the next page.</p>
<div style="page-break-after: always;"></div>

<p>In this first step, we are going to build the environment inside a class. Why a class? Because we would like to have our environment as an object which we can create easily with any values of some parameters we choose. For example, we can create one environment object for one server that has a certain number of connected users and a certain rate of data at a specific time, and one other environment object for another server that has a different number of connected users and a different rate of data at some other time. And thanks to this advanced structure of the class, we can easily plug-and-play the environment objects we create on different servers which have their own parameters, hence regulating their temperatures with several different AIs, so that we end up minimizing the energy consumption of a whole data center, just as Google DeepMind for Google’s data centers did with their DQN algorithm.</p>
<p><br />
</p>
<p>This class follows the below sub-steps, which are part of the general AI Framework inside Step 1 - Building the environment:</p>

<p>You will find the whole implementation of this Environment class in the next four pages. Remember the most important: all the code sections having their titles written in capital letters are the steps of the general AI Framework / Blueprint, and all the code sections having their titles written in minimal letters are specific to our case study.</p>
<p><br />
</p>
<p>Below is the whole implementation of our first python file. The code sections titles and the chosen variables names are clear enough to understand what is being coded, but if you need any more explanation, I encourage to watch our video tutorials where we code everything from scratch, step by step, while explaining every single line of code in terms of why, what and how. Here we go:</p>
<p><br />
</p>

<p><br />
</p>
<p>Congratulations for implementing Step 1 - Building the Environment. Now let’s move on to Step 2 - Building the Brain.</p>
<div style="page-break-after: always;"></div>

<p>In this Step 2, we are going to build the artificial brain of our AI, which is nothing else than a fully connected neural network. Here it is again:</p>

<p>Again, we will build this artificial brain inside a class, for the same reason as before which is to allow us to create several artificial brains for different servers inside a data center. Indeed, maybe some servers will need different artificial brains with different hyper-parameters than other servers. That’s why thanks to this class / object Python advanced structure, we can easily switch from one brain to another to regulate the temperature of a new server that requires an AI with different neural networks parameters.</p>
<p><br />
</p>
<p>We build this artificial brain thanks to the amazing Keras library. From this library we use the Dense() class to create our two fully connected hidden layers, the first one having 64 hidden neurons, and the second one having 32 neurons. And we use the Dense() class again to return Q-Values, which keep in mind are the outputs of the artificial neural networks. Then later on in the training and the testing files, we will use the argmax method to select the action that has the maximum Q-Value. Then, we assemble all the components of the brain, including the inputs and the outputs, by creating it as an object of the Model() class (very useful to then save and load a model with specific weights). End eventually, we compile it with a Mean-Squared Error loss and an Adam optimizer. Thus here are the new steps of the general AI Framework:</p>

<p>Here we go with the implementation:</p>
<p><br />
</p>

<p><br />
</p>
<p></p>
<p><br />
</p>
<p>I thought it would be valuable for you to even add one more powerful technique in your toolkit: .</p>
<p><br />
</p>
<p>Dropout is a regularization technique that prevents overfitting. It simply consists of deactivating a certain rate of random neurones during each step of forward &amp; back propagation. That way, not all the neurones learn the same way, thus preventing the neural network from overfitting the training data.</p>
<p><br />
</p>
<p>Here is how you implement Dropout:</p>

<p><br />
</p>
<p>Congratulations! You have implemented Dropout. It was very simple, once again thanks to Keras.</p>
<p>Below it the whole new brain.py implementation with Dropout:</p>
<p><br />
</p>

<p><br />
</p>
<p>Now let’s move on to next step of our general AI Framework: Step 3 - Implementing the DQN algorithm.</p>
<div style="page-break-after: always;"></div>

<p>In this new Python file, we simply have to follow the Deep Q-Learning algorithm provided before. Hence, this implementation follows the following sub-steps, which are part of the general AI Framework:</p>

<p>Below is the code following this new part of the AI Blueprint:</p>
<p><br />
</p>

<div style="page-break-after: always;"></div>

<p>Now that our AI has a fully functional brain, time to train it. And this is exactly what we do in this fourth Python file. The process is long, but very easy: we start by setting all the parameters, then we build the environment by creating an object of the Environment() class, then we build the brain of the AI by creating an object of the Brain() class, then we build the Deep Q-Learning model by creating an object of the DQN() class, and finally we launch the training connecting all these objects together, over 1000 epochs of 5-months period. You will notice in the training loop that we also do some exploration when playing the actions. This consists of playing some random actions from time to time. In our case study this will be done 30% of the time, since we use an exploration parameter <span class="math inline">\(\epsilon = 0.3\)</span>, and then we force to play a random action when drawing a random value between 0 and 1 that is below <span class="math inline">\(\epsilon = 0.3\)</span>). The reason why we do some exploration is because it improves the Deep Reinforcement Learning process. This trick is called: “Exploration vs. Exploitation”. Then, besides you will also notice that we use an early stopping technique, which will make sure to stop the training if there is performance improvement.</p>
<p><br />
</p>
<p>Let’s highlight these new steps that still belong to our general AI Framework / Blueprint:</p>

<p>And now let’s implement this new part, Step 4 - Training the AI, of our general Blueprint. Below is the whole implementation of this fourth python file. Again, the code sections titles and the chosen variables names are clear enough to understand what is being coded. Here we go:</p>
<p><br />
</p>

<p><br />
</p>
<p>After executing the code, we already see some good performance of our AI during the training, spending most of the time less energy than the alternative system, i.e. the server’s integrated cooling system. But that is only the training, now we need to see if we also obtain some good performance on a new 1-year simulation. That’s where our next, and final Python file, comes into play.</p>
<div style="page-break-after: always;"></div>

<p>Now indeed, we need to test the performance of our AI on a brand new situation. To do so, we will run a 1-year simulation, only in inference mode, meaning that there will be no training happening at any time. Our AI will only return predictions over a one full year of simulation. Then thanks to our environment object we will get in the end the total energy spent by the AI over this one full year, as well as the total energy spent by the server’s integrated cooling system. Eventually we will compare these two total energy spent, by simply computing their relative difference (in %), which will exactly give us the total energy saved by the AI. Buckle up for the final results, we will reveal them at the end of this Part 2!</p>
<p><br />
</p>
<p>In terms of the AI Blueprint, here for the testing implementation we almost have the same as before, except that this time, we don’t have to create a brain object nor a DQN model object, and of course we must not run the Deep Q-Learning process over some training epochs. However we do have to create a new environment object, and instead of creating a brain, we will load our artificial brain with its pre-trained weights from the previous training that we executed in Step 4 - Training the AI. Hence, let’s give the final sub-steps of this final part of the AI Framework / Blueprint:</p>

<p>And now let’s implement this fifth and final part, Step 5 - Testing the AI. Again, below is the whole implementation of our first python file. The code sections titles and the chosen variables names are clear enough to understand what is being coded, but if you need any more explanation, I encourage to watch our video tutorials where we code everything from scratch, step by step, while explaining every single line of code in terms of why, what and how. Here we go:</p>
<p><br />
</p>

<p><br />
</p>
<p>And finally, we obtain in the printed results that the total energy consumption saved by the AI is…:</p>
<p><span class="math display">\[\begin{equation*}
    \textrm{Total Energy saved by the AI} = 39 \ \% \ !
\end{equation*}\]</span></p>
<p>Exactly like what Google DeepMind achieved in 2016! Indeed, if on Google you type: “DeepMind reduces Google cooling bill”, you will see that the result they achieved is 40 %. Very close to ours!</p>
<p><br />
</p>
<p>Hence what we have built is surely excellent for our business client, as our AI will save them a lot of costs! Indeed, remember that thanks to our object oriented structure (working with classes and objects), we can very easily take our objects created in this implementation that we did for one server, and then plug them into other servers, so that in the end we end up saving the total energy consumption of a whole data center! That’s how Google saved billions of dollars in energy related costs, thanks to their DQN model built by DeepMind AI.</p>
<div style="page-break-after: always;"></div>

<p>Let’s recap and provide the whole AI Blueprint, so that you can print it out and put it on your wall.</p>
<p><br />
</p>
<p></p>

<p></p>

<p></p>

<p></p>

<p></p>


</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="optimización-de-procesos.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="part-3-maximizing-revenues.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/joanby/ia4business/edit/master/2.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["curso-ia-business-udemy.pdf", "curso-ia-business-udemy.epub"],
"toc": {
"collapse": "subsection"
},
"search": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
